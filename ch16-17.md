---
marp: true
theme: default
paginate: true
style: |
  /* Add "Page" prefix and total page number */
  section::after {
    font-size: 0.6em;
    content: attr(data-marpit-pagination) ' / ' attr(data-marpit-pagination-total);
  }
  thead:first-child {
      font-size: 0.8em;
      font-weight: 100;
  }
  img { mix-blend-mode: multiply; float: left; margin-right: 2em; }
---
<!-- _class: lead -->
<!-- _paginate: false -->

# Programming Rust <br /> Ch. 16-17

Sanguk Park `efenniht@furiosa.ai`

---

## Ch 16. Collections


| Collection                      | Description          |
| ------------------------------- | -------------------- |
| `Vec<T>`                        | Growable array       |
| `VecDeque<T>`                   | Growable ring buffer |
| `LinkedList<T>`                 | Doubly linked list   |
| `BinaryHeap<T>`                 | Max heap             |
| `HashMap<K, V>`, `HashSet<T>`   | Hash table           |
| `BTreeMap<K, V>`, `BTreeSet<T>` | Binary tree          |

---

## `Vec<T>`
: A heap-allocated growable array

Its memory layout is same as `(buffer, capacity, length)`

Ways to create a vector:
 - `Vec::new()`
 - `vec![a, b, c, ...]`
 - `vec![elem; cnt]` (where `elem: T` and `T: Clone`)
 - `Vec::with_capacity(n)`
 - `iterator.collect::<Vec<_>>()`
 - `slice.to_vec()` where `T: Clone`.
 - ...

---

## Capacity
: Vector 는 length 와 capacity를 모두 가지고, 항상 `length <= capacity`.
 
 - `Vec::with_capacity(n)`
 - `vec.capacity()`
 - `vec.reserve(n)`: `n` 개의 원소를 **추가로** 저장할 수 있도록 capcity를 증가시킴.
    + `length + n <= capacity`
 - `vec.reserve_exact(n)`: 정확히 `length + n = capacity` 가 되도록 alloc.
 - `vec.shrink_to_fit()`: 정확히 `length = capcity` 가 되도록 dealloc.

---

## Insert & Remove
원소 한 개:
 - `vec.push(x)`, `vec.pop() -> Option<T>`: 가장 끝에 insert / remove
 - `vec.insert(idx, x)`, `vec.remove(idx) -> T`

원소 여러 개:
 - `vec.resize(new_len, value)`: `new_len` 에 맞게 원소 삭제 / `value` 추가
 - `vec.truncate(new_len)`: `length <= new_len` 이 되도록 원소 삭제
 - `vec.clear()`: 모두 삭제
 - `vec.extend(iter)`: collect iterator into `vec`
 - `vec.split_off(idx)`: `vec.truncate(idx)` 후 잘린 부분을 vector로 return.
 - `vec.append(other: &mut Vec<T>)`: `other` 모두 `vec` 뒤에 추가, `other`는 empty.
 - `vec.drain(range) -> impl Iterator<Item=T>`: `range` 의 원소들을 remove

---

## Selectively Remove

 - `vec.retain(test: Fn(&T) -> bool)`: `test` 결과가 참인 것만 남김

연속된 원소들을 제거:
 - `vec.dedup()`
 - `vec.dedup_by(same: Fn(&T, &T) -> bool)`: `same` 을 기준으로
 - `vec.dedup_by_key(key: Fn(&T) -> K)`: `key` 를 기준으로

---

## Deref to Slice

```rust
impl<T> Deref<Target=[T]> for Vec<T> { .. }
```

Slice 에 있는 메서드를 모두 사용 가능:
 - `slice.len() -> usize`, `slice.is_empty() -> bool`
 - `slice.first() -> Option<&T>` the first element, if any.
 - `slice.last() -> Option<&T>` the last element, if any.
 - `slice.get(idx: usize) -> Option<&T>` the `idx`-th element, if any.
 - `slice[idx] -> T` panics if `slice.len() <= idx`.
 - `slice.iter() -> impl Iterator<Item=&T>`

모두 `mut` 버전이 있습니다.

---

## Splitting Slice

 - `slice.split_at(idx: usize)` = `(&slice[..idx], &slice[idx..])`
    
    Use `split_at_mut` instead of `(&mut slice[..idx], &mut slice[idx..])`

 - `slice.split_first() -> Option<(&T, &[T])>`
 - `slice.split_last() -> Option<(&[T], &T)>`
 - `slice.split(is_sep: F)`: separator 에 따라 split, returns iterator
 - `slice.splitn(n: usize, is_sep: F)`: 최대 `n` 개만 split
 - `slice.rsplitn(n: usize, is_Sep: F)`: 최대 `n` 개만 역순으로 split
 - `slice.chunks(n: usize)`: n 개 단위로 split

모두 `mut` 버전이 있습니다.

---

## Join

 - `[[1, 2], [3, 4]].concat() == vec![1, 2, 3, 4]`
 - `[[1, 2], [3, 4]].join(&0) == vec![1, 2, 0, 3, 4]`

## Sort, Swap and Reverse
 - `slice.sort()`: 오름차순으로 정렬 (`T: Ord`)
 - `slice.sort_by(cmp: Fn(&T, &T) -> Ordering)`: `cmp` 의 비교 결과에 따라 정렬
 - `slice.sort_by_key(key: Fn(&T) -> K)`: 각 원소의 `key` 를 오름차순으로 정렬

위 함수는 모두 stable sort 이고, `unstable` 버전도 있습니다.

 - `slice.swap(x, y)`
 - `slice.reverse()`

---

## Search

 - `slice.binary_search(v: &T)`
 - `slice.binary_search_by(v: &T, cmp)`
 - `slice.binary_search_by_key(v: &T, key)`
<br />
- 해당하는 원소를 찾으면 위치를 `Ok(idx)` 로 리턴.
- 그렇지 않으면, 순서를 깨지 않고 `v`를 넣을 수 있는 위치를 `Err(idx)` 로 리턴.
<br />
- `slice.contains(v: &T) -> bool`
- 위치를 알려면: `slice.iter().position(|x| *x == v)`

---

## Compare

 - `[1, 2, 3] == [1, 2, 3]`, `[1, 2] != [1, 2, 3]`
 - `[1, 2, 3] < [1, 2, 4]` (lexicographical order)
 - `slice.starts_with(other: &[T])`
 - `slice.ends_with(other: &[T])`

## Random

`rand` crate 필요.

 - `rng.choose(slice: &[T]) -> Option<&T>`
 - `rng.shuffle(slice: &mut [T])`

---

## No Invalidation Error

```rust
for (idx, &val) in vec.iter().enumerate() {
    if val < 4 {
        vec.remove(idx); // ERROR: can't borrow `vec` as mutable
    }
}
```

$\Rightarrow$

```rust
vec.retain(|&x| x >= 4)
```

---

## `VecDeque<T>`

